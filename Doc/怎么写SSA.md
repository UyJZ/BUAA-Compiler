# 怎么写`SSA`

`SSA` Static Single-Assignment 据说是一种非常好的优化，此时此刻的笔者还不知道他的分量，专门写一份博客去记录学习`SSA`的过程。

## 初始SSA

略，教程部分是说明形式的文档，相信学了`llvm`都可以看懂

## `mem2reg`

字面意思是把内存换成寄存器？下面来看看吧

### 插入`phi`指令

在这一个步骤里，我们会把构建SSA所需要插入的phi指令都一口气先插到里面。当我们遇到不同基本块汇集（converge）到同一个基本块的时候，便需要将phi指令插入到基本块中。看下面的例子

![image-20231126220752047](C:\Users\dell\AppData\Roaming\Typora\typora-LLVMUser-images\image-20231126220752047.png)

其中D是B和C， E是C和D， A是entry和D的`join node`

在如果在B&C中对同一个Value进行了定义，那么就得往D中插入一个针对这个Value 的 phi指令。

实际情况是非常复杂的比如D之后有可能又回到了B或者C之类的，因此单一的`join node`是不够的，提出`join set`：

* 设$S$是一个基本块集合
* 当$n$为$S$中至少两个基本快$n_1n_2$的`join node`的时候，可以说$n$是$S$的一个`join node`
* 将$S$的所有`join node`汇聚起来就是`join set`，记作$J(S)$

所以这玩意咋用？很简单，对每个`Value`，求出他的所有定义集合$D_v$，然后对$J(D_v)$插入相应的`phi`指令就ok!听起来好像问题要解决了，但是仔细想想，这玩意的求解过程复杂的一批，所以计算机科学家们搞了图论中的一些概念来转化问题。

* **dominate**:如果CFG（流程控制图）中从起始节点到基本块`y`的路径都经过了基本快x，则说**x支配y**
* **strict dominate**:显然每个基本块都支配他自己，如果x支配y，$x \ne y$则**x严格支配y**
* **直接支配者**：严格支配n，且不严格支配任何严格支配n的节点的节点，说白话就是支配者中离n最近的一个

有一点听显然的：每个节点的直接支配者有且仅有一个（除了entry，这玩意是入口）

#### 支配边界(Dominate Frontier)

节点n的支配边界时CFG中刚刚号不被n支配的节点的集合，形式化的定义是：
$$
DF(x) = \{x | n支配x的前驱节点，n不严格支配x\}
$$
就是说，在此之间n对节点都是路径支配的，但是在这个集合中出现了其他的可能性，这些其实很好想的一点就是这些可能性并不是凭空产生的，所以说一个节点x，他时一个支配边界，那他必然是不止一个节点的支配边界，对于在这些块中定义的变量，如果这个节点x也对这个节点进行了定义，那么这个节点必然也是`join node`



具体代码实现已经鸽了，写完了就不想写文档了qwq





## `SSA destruction` 又称`de-SSA`

这玩意乍一看挺恶心的，我才做了SSA，你又得给我消掉，没有办法，`phi`不存在对应的指令，毕竟这玩意是个并行指令。

### 关键边`critical edges`

关键边是从一个有多个后继的节点指向有多个前驱的节点的边。消PHI最简单的一个思路是在源基本块跳转之前将PHI指令拆成多条move指令

这一段话一听就挺懵逼的。为啥啊？？？

其实可以这么理解

块1和块2都是跳转到块3，块3开头有个`phi: %x = phi [%1, BB1], [%2, BB2]`最简单的思路肯定就是在`BB1`末尾加一个`move %x %1`，在`BB2`末尾加一个`move %x %2`，这样的话我们就肯定可以找得到我们需要的`%x`啦，但是这玩意显然是一大坨漏洞的，因为一个块可以跳到好几个块，这么赋值时有可能出问题的，所以要引出这个关键边的概念，将每一种跳转分别赋值一个move，这样的话就能保证对应的`move`是正确的